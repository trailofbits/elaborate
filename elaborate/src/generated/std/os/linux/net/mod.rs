// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;


#[cfg(target_os = "linux")]
pub trait SocketAddrExtContext: std :: os :: linux :: net :: SocketAddrExt {
fn as_abstract_name_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & [ u8 ] > ) {
    < Self as :: std :: os :: linux :: net :: SocketAddrExt > :: as_abstract_name(self)
        .with_context(|| crate::call_failed!(Some(self), "as_abstract_name"))
}
#[cfg(unix)]
fn from_abstract_name_wc < N > ( name : N ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) where N : core :: convert :: AsRef < [ u8 ] > {
    let name = name.as_ref();
    < Self as :: std :: os :: linux :: net :: SocketAddrExt > :: from_abstract_name(name)
        .with_context(|| crate::call_failed!(None::<()>, "< Self as :: std :: os :: linux :: net :: SocketAddrExt > :: from_abstract_name", name))
}
}

#[cfg(target_os = "linux")]
impl<T> SocketAddrExtContext for T where T: std :: os :: linux :: net :: SocketAddrExt {}
#[cfg(feature = "tcp_quickack")]
#[cfg(target_os = "linux")]
pub trait TcpStreamExtContext: std :: os :: linux :: net :: TcpStreamExt {
#[cfg(feature = "tcp_deferaccept")]
fn deferaccept_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u32 > ) {
    < Self as :: std :: os :: linux :: net :: TcpStreamExt > :: deferaccept(self)
        .with_context(|| crate::call_failed!(Some(self), "deferaccept"))
}
#[cfg(feature = "tcp_deferaccept")]
fn set_deferaccept_wc ( & self , accept : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: linux :: net :: TcpStreamExt > :: set_deferaccept(self, accept)
        .with_context(|| crate::call_failed!(Some(self), "set_deferaccept", accept))
}
#[cfg(feature = "tcp_quickack")]
fn quickack_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {
    < Self as :: std :: os :: linux :: net :: TcpStreamExt > :: quickack(self)
        .with_context(|| crate::call_failed!(Some(self), "quickack"))
}
#[cfg(feature = "tcp_quickack")]
fn set_quickack_wc ( & self , quickack : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: linux :: net :: TcpStreamExt > :: set_quickack(self, quickack)
        .with_context(|| crate::call_failed!(Some(self), "set_quickack", quickack))
}
}

#[cfg(feature = "tcp_quickack")]
#[cfg(target_os = "linux")]
impl<T> TcpStreamExtContext for T where T: std :: os :: linux :: net :: TcpStreamExt {}
#[cfg(feature = "unix_socket_ancillary_data")]
#[cfg(target_os = "linux")]
pub trait UnixSocketExtContext: std :: os :: linux :: net :: UnixSocketExt {
fn passcred_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {
    < Self as :: std :: os :: linux :: net :: UnixSocketExt > :: passcred(self)
        .with_context(|| crate::call_failed!(Some(self), "passcred"))
}
fn set_passcred_wc ( & self , passcred : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: linux :: net :: UnixSocketExt > :: set_passcred(self, passcred)
        .with_context(|| crate::call_failed!(Some(self), "set_passcred", passcred))
}
}

#[cfg(feature = "unix_socket_ancillary_data")]
#[cfg(target_os = "linux")]
impl<T> UnixSocketExtContext for T where T: std :: os :: linux :: net :: UnixSocketExt {}


