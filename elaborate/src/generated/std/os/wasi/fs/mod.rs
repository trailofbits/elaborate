// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;


#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub trait FileExtContext: std :: os :: wasi :: fs :: FileExt {
/// Adjusts the flags associated with this file.
/// 
/// This corresponds to the `fd_fdstat_set_flags` syscall.
fn fdstat_set_flags_wc ( & self , flags : u16 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: fdstat_set_flags(self, flags)
        .with_context(|| crate::call_failed!(Some(self), "fdstat_set_flags", flags))
}
/// Adjusts the rights associated with this file.
/// 
/// This corresponds to the `fd_fdstat_set_rights` syscall.
fn fdstat_set_rights_wc ( & self , rights : u64 , inheriting : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: fdstat_set_rights(self, rights, inheriting)
        .with_context(|| crate::call_failed!(Some(self), "fdstat_set_rights", rights, inheriting))
}
/// Attempts to write an entire buffer starting from a given offset.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// This method will continuously call [`write_at`] until there is no more data
/// to be written or an error of non-[`io::ErrorKind::Interrupted`] kind is
/// returned. This method will not return until the entire buffer has been
/// successfully written or such an error occurs. The first error that is
/// not of [`io::ErrorKind::Interrupted`] kind generated from this method will be
/// returned.
/// 
/// # Errors
/// 
/// This function will return the first error of
/// non-[`io::ErrorKind::Interrupted`] kind that [`write_at`] returns.
/// 
/// [`write_at`]: FileExt::write_at
fn write_all_at_wc ( & self , buf : & [ u8 ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: write_all_at(self, buf, offset)
        .with_context(|| crate::call_failed!(Some(self), "write_all_at", buf, offset))
}
/// Creates a directory.
/// 
/// This corresponds to the `path_create_directory` syscall.
fn create_directory_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , dir : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let dir = dir.as_ref();
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: create_directory(self, dir)
        .with_context(|| crate::call_failed!(Some(self), "create_directory", dir))
}
/// Forces the allocation of space in a file.
/// 
/// This corresponds to the `fd_allocate` syscall.
fn allocate_wc ( & self , offset : u64 , len : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: allocate(self, offset, len)
        .with_context(|| crate::call_failed!(Some(self), "allocate", offset, len))
}
/// Provides file advisory information on a file descriptor.
/// 
/// This corresponds to the `fd_advise` syscall.
fn advise_wc ( & self , offset : u64 , len : u64 , advice : u8 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: advise(self, offset, len, advice)
        .with_context(|| crate::call_failed!(Some(self), "advise", offset, len, advice))
}
/// Reads a number of bytes starting from a given offset.
/// 
/// Returns the number of bytes read.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// Note that similar to [`File::read_vectored`], it is not an error to
/// return with a short read.
fn read_vectored_at_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: read_vectored_at(self, bufs, offset)
        .with_context(|| crate::call_failed!(Some(self), "read_vectored_at", bufs, offset))
}
/// Reads a number of bytes starting from a given offset.
/// 
/// Returns the number of bytes read.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// Note that similar to [`File::read`], it is not an error to return with a
/// short read.
fn read_at_wc ( & self , buf : & mut [ u8 ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: read_at(self, buf, offset)
        .with_context(|| crate::call_failed!(Some(self), "read_at", buf, offset))
}
/// Reads the contents of a symbolic link.
/// 
/// This corresponds to the `path_readlink` syscall.
fn read_link_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    let path = path.as_ref();
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: read_link(self, path)
        .with_context(|| crate::call_failed!(Some(self), "read_link", path))
}
/// Reads the exact number of byte required to fill `buf` from the given offset.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.
/// 
/// [`read_at`]: FileExt::read_at
/// 
/// # Errors
/// 
/// If this function encounters an error of the kind
/// [`io::ErrorKind::Interrupted`] then the error is ignored and the operation
/// will continue.
/// 
/// If this function encounters an "end of file" before completely filling
/// the buffer, it returns an error of the kind [`io::ErrorKind::UnexpectedEof`].
/// The contents of `buf` are unspecified in this case.
/// 
/// If any other read error is encountered then this function immediately
/// returns. The contents of `buf` are unspecified in this case.
/// 
/// If this function returns an error, it is unspecified how many bytes it
/// has read, but it will never read more than would be necessary to
/// completely fill the buffer.
fn read_exact_at_wc ( & self , buf : & mut [ u8 ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: read_exact_at(self, buf, offset)
        .with_context(|| crate::call_failed!(Some(self), "read_exact_at", buf, offset))
}
/// Removes a directory.
/// 
/// This corresponds to the `path_remove_directory` syscall.
fn remove_directory_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: remove_directory(self, path)
        .with_context(|| crate::call_failed!(Some(self), "remove_directory", path))
}
/// Returns the attributes of a file or directory.
/// 
/// This corresponds to the `path_filestat_get` syscall.
fn metadata_at_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , lookup_flags : u32 , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {
    let path = path.as_ref();
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: metadata_at(self, lookup_flags, path)
        .with_context(|| crate::call_failed!(Some(self), "metadata_at", lookup_flags, path))
}
/// Unlinks a file.
/// 
/// This corresponds to the `path_unlink_file` syscall.
fn remove_file_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: remove_file(self, path)
        .with_context(|| crate::call_failed!(Some(self), "remove_file", path))
}
/// Writes a number of bytes starting from a given offset.
/// 
/// Returns the number of bytes written.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// When writing beyond the end of the file, the file is appropriately
/// extended and the intermediate bytes are initialized with the value 0.
/// 
/// Note that similar to [`File::write_vectored`], it is not an error to return a
/// short write.
fn write_vectored_at_wc ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: write_vectored_at(self, bufs, offset)
        .with_context(|| crate::call_failed!(Some(self), "write_vectored_at", bufs, offset))
}
/// Writes a number of bytes starting from a given offset.
/// 
/// Returns the number of bytes written.
/// 
/// The offset is relative to the start of the file and thus independent
/// from the current cursor.
/// 
/// The current file cursor is not affected by this function.
/// 
/// When writing beyond the end of the file, the file is appropriately
/// extended and the intermediate bytes are initialized with the value 0.
/// 
/// Note that similar to [`File::write`], it is not an error to return a
/// short write.
fn write_at_wc ( & self , buf : & [ u8 ] , offset : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: os :: wasi :: fs :: FileExt > :: write_at(self, buf, offset)
        .with_context(|| crate::call_failed!(Some(self), "write_at", buf, offset))
}
}

#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
impl<T> FileExtContext for T where T: std :: os :: wasi :: fs :: FileExt {}
#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub trait OpenOptionsExtContext: std :: os :: wasi :: fs :: OpenOptionsExt {
/// Open a file or directory.
/// 
/// This corresponds to the `path_open` syscall.
fn open_at_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , file : & std :: fs :: File , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: File > ) {
    let path = path.as_ref();
    < Self as :: std :: os :: wasi :: fs :: OpenOptionsExt > :: open_at(self, file, path)
        .with_context(|| crate::call_failed!(Some(self), "open_at", file, path))
}
}

#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
impl<T> OpenOptionsExtContext for T where T: std :: os :: wasi :: fs :: OpenOptionsExt {}



/// Creates a hard link.
/// 
/// This corresponds to the `path_link` syscall.
#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub fn link_wc < P : core :: convert :: AsRef < std :: path :: Path > , U : core :: convert :: AsRef < std :: path :: Path > > ( old_fd : & std :: fs :: File , old_flags : u32 , old_path : P , new_fd : & std :: fs :: File , new_path : U ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let old_path = old_path.as_ref();
    let new_path = new_path.as_ref();
    std :: os :: wasi :: fs :: link(old_fd, old_flags, old_path, new_fd, new_path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::wasi::fs::link", old_fd, old_flags, old_path, new_fd, new_path))
}
/// Creates a symbolic link.
/// 
/// This corresponds to the `path_symlink` syscall.
#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub fn symlink_wc < P : core :: convert :: AsRef < std :: path :: Path > , U : core :: convert :: AsRef < std :: path :: Path > > ( old_path : P , fd : & std :: fs :: File , new_path : U ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let old_path = old_path.as_ref();
    let new_path = new_path.as_ref();
    std :: os :: wasi :: fs :: symlink(old_path, fd, new_path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::wasi::fs::symlink", old_path, fd, new_path))
}
/// Creates a symbolic link.
/// 
/// This is a convenience API similar to `std::os::unix::fs::symlink` and
/// `std::os::windows::fs::symlink_file` and `std::os::windows::fs::symlink_dir`.
#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub fn symlink_path_wc < P : core :: convert :: AsRef < std :: path :: Path > , U : core :: convert :: AsRef < std :: path :: Path > > ( old_path : P , new_path : U ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let old_path = old_path.as_ref();
    let new_path = new_path.as_ref();
    std :: os :: wasi :: fs :: symlink_path(old_path, new_path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::wasi::fs::symlink_path", old_path, new_path))
}
/// Renames a file or directory.
/// 
/// This corresponds to the `path_rename` syscall.
#[cfg(feature = "wasi_ext")]
#[cfg(target_os = "wasi")]
pub fn rename_wc < P : core :: convert :: AsRef < std :: path :: Path > , U : core :: convert :: AsRef < std :: path :: Path > > ( old_fd : & std :: fs :: File , old_path : P , new_fd : & std :: fs :: File , new_path : U ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let old_path = old_path.as_ref();
    let new_path = new_path.as_ref();
    std :: os :: wasi :: fs :: rename(old_fd, old_path, new_fd, new_path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::wasi::fs::rename", old_fd, old_path, new_fd, new_path))
}
