// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[cfg(unix)]
pub trait SocketAddrContext: Sized {
fn as_pathname_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: path :: Path > );
fn from_pathname_wc < P > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) where P : core :: convert :: AsRef < std :: path :: Path >;
}
#[cfg(unix)]
impl SocketAddrContext for std :: os :: unix :: net :: SocketAddr {
fn as_pathname_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: path :: Path > ) {
    std :: os :: unix :: net :: SocketAddr :: as_pathname(self)
        .with_context(|| crate::call_failed!(Some(self), "as_pathname"))
}
fn from_pathname_wc < P > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) where P : core :: convert :: AsRef < std :: path :: Path > {
    let path = path.as_ref();
    std :: os :: unix :: net :: SocketAddr :: from_pathname(path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::SocketAddr::from_pathname", path))
}
}
#[cfg(unix)]
pub trait UnixDatagramContext: Sized {
#[cfg(feature = "unix_set_mark")]
fn set_mark_wc ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_from_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool , std :: os :: unix :: net :: SocketAddr ) > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool ) > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_to_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_wc ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
#[cfg(feature = "unix_socket_peek")]
fn peek_from_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > );
#[cfg(feature = "unix_socket_peek")]
fn peek_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn bind_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn bind_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn connect_addr_wc ( & self , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn connect_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > );
fn pair_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > );
fn peer_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > );
fn read_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > );
fn recv_from_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > );
fn recv_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn send_to_addr_wc ( & self , buf : & [ u8 ] , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn send_to_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , buf : & [ u8 ] , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn send_wc ( & self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn set_read_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn set_write_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn shutdown_wc ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > );
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn unbound_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn write_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > );
}
#[cfg(unix)]
impl UnixDatagramContext for std :: os :: unix :: net :: UnixDatagram {
#[cfg(feature = "unix_set_mark")]
fn set_mark_wc ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: set_mark(self, mark)
        .with_context(|| crate::call_failed!(Some(self), "set_mark", mark))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_from_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool , std :: os :: unix :: net :: SocketAddr ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: recv_vectored_with_ancillary_from(self, bufs, ancillary)
        .with_context(|| crate::call_failed!(Some(self), "recv_vectored_with_ancillary_from", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: recv_vectored_with_ancillary(self, bufs, ancillary)
        .with_context(|| crate::call_failed!(Some(self), "recv_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_to_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixDatagram :: send_vectored_with_ancillary_to(self, bufs, ancillary, path)
        .with_context(|| crate::call_failed!(Some(self), "send_vectored_with_ancillary_to", bufs, ancillary, path))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_wc ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixDatagram :: send_vectored_with_ancillary(self, bufs, ancillary)
        .with_context(|| crate::call_failed!(Some(self), "send_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_peek")]
fn peek_from_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: peek_from(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "peek_from", buf))
}
#[cfg(feature = "unix_socket_peek")]
fn peek_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixDatagram :: peek(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "peek", buf))
}
fn bind_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixDatagram :: bind_addr(socket_addr)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixDatagram::bind_addr", socket_addr))
}
fn bind_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixDatagram :: bind(path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixDatagram::bind", path))
}
fn connect_addr_wc ( & self , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: connect_addr(self, socket_addr)
        .with_context(|| crate::call_failed!(Some(self), "connect_addr", socket_addr))
}
fn connect_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixDatagram :: connect(self, path)
        .with_context(|| crate::call_failed!(Some(self), "connect", path))
}
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {
    std :: os :: unix :: net :: UnixDatagram :: local_addr(self)
        .with_context(|| crate::call_failed!(Some(self), "local_addr"))
}
fn pair_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: pair()
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixDatagram::pair"))
}
fn peer_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {
    std :: os :: unix :: net :: UnixDatagram :: peer_addr(self)
        .with_context(|| crate::call_failed!(Some(self), "peer_addr"))
}
fn read_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {
    std :: os :: unix :: net :: UnixDatagram :: read_timeout(self)
        .with_context(|| crate::call_failed!(Some(self), "read_timeout"))
}
fn recv_from_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: recv_from(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "recv_from", buf))
}
fn recv_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixDatagram :: recv(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "recv", buf))
}
fn send_to_addr_wc ( & self , buf : & [ u8 ] , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixDatagram :: send_to_addr(self, buf, socket_addr)
        .with_context(|| crate::call_failed!(Some(self), "send_to_addr", buf, socket_addr))
}
fn send_to_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , buf : & [ u8 ] , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixDatagram :: send_to(self, buf, path)
        .with_context(|| crate::call_failed!(Some(self), "send_to", buf, path))
}
fn send_wc ( & self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixDatagram :: send(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "send", buf))
}
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: set_nonblocking(self, nonblocking)
        .with_context(|| crate::call_failed!(Some(self), "set_nonblocking", nonblocking))
}
fn set_read_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: set_read_timeout(self, timeout)
        .with_context(|| crate::call_failed!(Some(self), "set_read_timeout", timeout))
}
fn set_write_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: set_write_timeout(self, timeout)
        .with_context(|| crate::call_failed!(Some(self), "set_write_timeout", timeout))
}
fn shutdown_wc ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixDatagram :: shutdown(self, how)
        .with_context(|| crate::call_failed!(Some(self), "shutdown", how))
}
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {
    std :: os :: unix :: net :: UnixDatagram :: take_error(self)
        .with_context(|| crate::call_failed!(Some(self), "take_error"))
}
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixDatagram :: try_clone(self)
        .with_context(|| crate::call_failed!(Some(self), "try_clone"))
}
fn unbound_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixDatagram :: unbound()
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixDatagram::unbound"))
}
fn write_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {
    std :: os :: unix :: net :: UnixDatagram :: write_timeout(self)
        .with_context(|| crate::call_failed!(Some(self), "write_timeout"))
}
}
#[cfg(unix)]
pub trait UnixListenerContext: Sized {
fn accept_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( std :: os :: unix :: net :: UnixStream , std :: os :: unix :: net :: SocketAddr ) > );
fn bind_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn bind_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > );
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > );
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
}
#[cfg(unix)]
impl UnixListenerContext for std :: os :: unix :: net :: UnixListener {
fn accept_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( std :: os :: unix :: net :: UnixStream , std :: os :: unix :: net :: SocketAddr ) > ) {
    std :: os :: unix :: net :: UnixListener :: accept(self)
        .with_context(|| crate::call_failed!(Some(self), "accept"))
}
fn bind_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixListener :: bind_addr(socket_addr)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixListener::bind_addr", socket_addr))
}
fn bind_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixListener :: bind(path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixListener::bind", path))
}
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {
    std :: os :: unix :: net :: UnixListener :: local_addr(self)
        .with_context(|| crate::call_failed!(Some(self), "local_addr"))
}
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixListener :: set_nonblocking(self, nonblocking)
        .with_context(|| crate::call_failed!(Some(self), "set_nonblocking", nonblocking))
}
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {
    std :: os :: unix :: net :: UnixListener :: take_error(self)
        .with_context(|| crate::call_failed!(Some(self), "take_error"))
}
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixListener :: try_clone(self)
        .with_context(|| crate::call_failed!(Some(self), "try_clone"))
}
}
#[cfg(unix)]
pub trait UnixStreamContext: Sized {
#[cfg(feature = "peer_credentials_unix_socket")]
fn peer_cred_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: UCred > );
#[cfg(feature = "unix_set_mark")]
fn set_mark_wc ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_wc ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
#[cfg(feature = "unix_socket_peek")]
fn peek_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
fn connect_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn connect_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > );
fn pair_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > );
fn peer_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > );
fn read_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > );
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn set_read_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn set_write_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn shutdown_wc ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > );
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > );
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > );
fn write_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > );
}
#[cfg(unix)]
impl UnixStreamContext for std :: os :: unix :: net :: UnixStream {
#[cfg(feature = "peer_credentials_unix_socket")]
fn peer_cred_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: UCred > ) {
    std :: os :: unix :: net :: UnixStream :: peer_cred(self)
        .with_context(|| crate::call_failed!(Some(self), "peer_cred"))
}
#[cfg(feature = "unix_set_mark")]
fn set_mark_wc ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixStream :: set_mark(self, mark)
        .with_context(|| crate::call_failed!(Some(self), "set_mark", mark))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn recv_vectored_with_ancillary_wc ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixStream :: recv_vectored_with_ancillary(self, bufs, ancillary)
        .with_context(|| crate::call_failed!(Some(self), "recv_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
fn send_vectored_with_ancillary_wc ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixStream :: send_vectored_with_ancillary(self, bufs, ancillary)
        .with_context(|| crate::call_failed!(Some(self), "send_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_peek")]
fn peek_wc ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: os :: unix :: net :: UnixStream :: peek(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "peek", buf))
}
fn connect_addr_wc ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixStream :: connect_addr(socket_addr)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixStream::connect_addr", socket_addr))
}
fn connect_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();
    std :: os :: unix :: net :: UnixStream :: connect(path)
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixStream::connect", path))
}
fn local_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {
    std :: os :: unix :: net :: UnixStream :: local_addr(self)
        .with_context(|| crate::call_failed!(Some(self), "local_addr"))
}
fn pair_wc ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > ) {
    std :: os :: unix :: net :: UnixStream :: pair()
        .with_context(|| crate::call_failed!(None::<()>, "std::os::unix::net::UnixStream::pair"))
}
fn peer_addr_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {
    std :: os :: unix :: net :: UnixStream :: peer_addr(self)
        .with_context(|| crate::call_failed!(Some(self), "peer_addr"))
}
fn read_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {
    std :: os :: unix :: net :: UnixStream :: read_timeout(self)
        .with_context(|| crate::call_failed!(Some(self), "read_timeout"))
}
fn set_nonblocking_wc ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixStream :: set_nonblocking(self, nonblocking)
        .with_context(|| crate::call_failed!(Some(self), "set_nonblocking", nonblocking))
}
fn set_read_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixStream :: set_read_timeout(self, timeout)
        .with_context(|| crate::call_failed!(Some(self), "set_read_timeout", timeout))
}
fn set_write_timeout_wc ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixStream :: set_write_timeout(self, timeout)
        .with_context(|| crate::call_failed!(Some(self), "set_write_timeout", timeout))
}
fn shutdown_wc ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    std :: os :: unix :: net :: UnixStream :: shutdown(self, how)
        .with_context(|| crate::call_failed!(Some(self), "shutdown", how))
}
fn take_error_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {
    std :: os :: unix :: net :: UnixStream :: take_error(self)
        .with_context(|| crate::call_failed!(Some(self), "take_error"))
}
fn try_clone_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    std :: os :: unix :: net :: UnixStream :: try_clone(self)
        .with_context(|| crate::call_failed!(Some(self), "try_clone"))
}
fn write_timeout_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {
    std :: os :: unix :: net :: UnixStream :: write_timeout(self)
        .with_context(|| crate::call_failed!(Some(self), "write_timeout"))
}
}

