// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;


pub trait BufReadContext: std :: io :: BufRead {
fn fill_buf_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < & [ u8 ] > ) {
    < Self as :: std :: io :: BufRead > :: fill_buf(self)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type impl std::io::BufRead")), "fill_buf"))
}
fn read_line_wc ( & mut self , buf : & mut std :: string :: String ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: BufRead > :: read_line(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_line", buf))
}
fn read_until_wc ( & mut self , byte : u8 , buf : & mut std :: vec :: Vec < u8 > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: BufRead > :: read_until(self, byte, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_until", byte, buf))
}
#[cfg(feature = "buf_read_has_data_left")]
fn has_data_left_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {
    < Self as :: std :: io :: BufRead > :: has_data_left(self)
        .with_context(|| crate::call_failed!(Some(self), "has_data_left"))
}
#[cfg(feature = "bufread_skip_until")]
fn skip_until_wc ( & mut self , byte : u8 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: BufRead > :: skip_until(self, byte)
        .with_context(|| crate::call_failed!(Some(self), "skip_until", byte))
}
}

impl<T> BufReadContext for T where T: std :: io :: BufRead {}
pub trait ReadContext: std :: io :: Read {
fn read_exact_wc ( & mut self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Read > :: read_exact(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_exact", buf))
}
fn read_to_end_wc ( & mut self , buf : & mut std :: vec :: Vec < u8 > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Read > :: read_to_end(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_to_end", buf))
}
fn read_to_string_wc ( & mut self , buf : & mut std :: string :: String ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Read > :: read_to_string(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_to_string", buf))
}
fn read_vectored_wc ( & mut self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Read > :: read_vectored(self, bufs)
        .with_context(|| crate::call_failed!(Some(self), "read_vectored", bufs))
}
fn read_wc ( & mut self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Read > :: read(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read", buf))
}
#[cfg(feature = "read_buf")]
fn read_buf_exact_wc ( & mut self , cursor : core :: io :: borrowed_buf :: BorrowedCursor < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Read > :: read_buf_exact(self, cursor)
        .with_context(|| crate::call_failed!(Some(self), "read_buf_exact", cursor))
}
#[cfg(feature = "read_buf")]
fn read_buf_wc ( & mut self , buf : core :: io :: borrowed_buf :: BorrowedCursor < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Read > :: read_buf(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_buf", buf))
}
}

impl<T> ReadContext for T where T: std :: io :: Read {}
pub trait SeekContext: std :: io :: Seek {
fn rewind_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Seek > :: rewind(self)
        .with_context(|| crate::call_failed!(Some(self), "rewind"))
}
fn seek_relative_wc ( & mut self , offset : i64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Seek > :: seek_relative(self, offset)
        .with_context(|| crate::call_failed!(Some(self), "seek_relative", offset))
}
fn seek_wc ( & mut self , pos : std :: io :: SeekFrom ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u64 > ) {
    < Self as :: std :: io :: Seek > :: seek(self, pos)
        .with_context(|| crate::call_failed!(Some(self), "seek", pos))
}
fn stream_position_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u64 > ) {
    < Self as :: std :: io :: Seek > :: stream_position(self)
        .with_context(|| crate::call_failed!(Some(self), "stream_position"))
}
#[cfg(feature = "seek_stream_len")]
fn stream_len_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u64 > ) {
    < Self as :: std :: io :: Seek > :: stream_len(self)
        .with_context(|| crate::call_failed!(Some(self), "stream_len"))
}
}

impl<T> SeekContext for T where T: std :: io :: Seek {}
pub trait WriteContext: std :: io :: Write {
fn flush_wc ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Write > :: flush(self)
        .with_context(|| crate::call_failed!(Some(self), "flush"))
}
fn write_all_wc ( & mut self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Write > :: write_all(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "write_all", buf))
}
fn write_fmt_wc ( & mut self , fmt : core :: fmt :: Arguments < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Write > :: write_fmt(self, fmt)
        .with_context(|| crate::call_failed!(Some(self), "write_fmt", fmt))
}
fn write_vectored_wc ( & mut self , bufs : & [ std :: io :: IoSlice < '_ > ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Write > :: write_vectored(self, bufs)
        .with_context(|| crate::call_failed!(Some(self), "write_vectored", bufs))
}
fn write_wc ( & mut self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    < Self as :: std :: io :: Write > :: write(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "write", buf))
}
#[cfg(feature = "write_all_vectored")]
fn write_all_vectored_wc ( & mut self , bufs : & mut [ std :: io :: IoSlice < '_ > ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    < Self as :: std :: io :: Write > :: write_all_vectored(self, bufs)
        .with_context(|| crate::call_failed!(Some(self), "write_all_vectored", bufs))
}
}

impl<T> WriteContext for T where T: std :: io :: Write {}

pub trait ErrorContext {
fn get_mut_wc ( & mut self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & mut ( dyn core :: error :: Error + core :: marker :: Send + core :: marker :: Sync + 'static ) > );
fn get_ref_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & ( dyn core :: error :: Error + core :: marker :: Send + core :: marker :: Sync + 'static ) > );
#[cfg(feature = "raw_os_error_ty")]
fn raw_os_error_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < std :: io :: RawOsError > );
}
impl ErrorContext for std :: io :: Error {
fn get_mut_wc ( & mut self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & mut ( dyn core :: error :: Error + core :: marker :: Send + core :: marker :: Sync + 'static ) > ) {
    std :: io :: Error :: get_mut(self)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type std::io::Error")), "get_mut"))
}
fn get_ref_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & ( dyn core :: error :: Error + core :: marker :: Send + core :: marker :: Sync + 'static ) > ) {
    std :: io :: Error :: get_ref(self)
        .with_context(|| crate::call_failed!(Some(self), "get_ref"))
}
#[cfg(feature = "raw_os_error_ty")]
fn raw_os_error_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < std :: io :: RawOsError > ) {
    std :: io :: Error :: raw_os_error(self)
        .with_context(|| crate::call_failed!(Some(self), "raw_os_error"))
}
}
pub trait StdinContext {
fn read_line_wc ( & self , buf : & mut std :: string :: String ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > );
}
impl StdinContext for std :: io :: Stdin {
fn read_line_wc ( & self , buf : & mut std :: string :: String ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    std :: io :: Stdin :: read_line(self, buf)
        .with_context(|| crate::call_failed!(Some(self), "read_line", buf))
}
}


pub fn copy_wc < R , W > ( reader : & mut R , writer : & mut W ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u64 > ) where R : std :: io :: Read + ? core :: marker :: Sized , W : std :: io :: Write + ? core :: marker :: Sized {
    std :: io :: copy(reader, writer)
        .with_context(|| crate::call_failed!(None::<()>, "std :: io :: copy", reader, writer))
}
pub fn read_to_string_wc < R : std :: io :: Read > ( reader : R ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: string :: String > ) {
    std :: io :: read_to_string(reader)
        .with_context(|| crate::call_failed!(None::<()>, "std :: io :: read_to_string", crate::CustomDebugMessage("value of type impl Read")))
}
