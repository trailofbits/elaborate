// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



pub trait PathBufContext {
fn try_reserve_exact_wc ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > );
fn try_reserve_wc ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > );
}
impl PathBufContext for std :: path :: PathBuf {
fn try_reserve_exact_wc ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > ) {
    std :: path :: PathBuf :: try_reserve_exact(self, additional)
        .with_context(|| crate::call_failed!(Some(self), "try_reserve_exact", additional))
}
fn try_reserve_wc ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > ) {
    std :: path :: PathBuf :: try_reserve(self, additional)
        .with_context(|| crate::call_failed!(Some(self), "try_reserve", additional))
}
}
pub trait PathContext {
fn canonicalize_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > );
fn extension_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > );
fn file_name_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > );
fn file_stem_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > );
fn metadata_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > );
fn parent_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & Self > );
fn read_dir_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: ReadDir > );
fn read_link_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > );
fn strip_prefix_wc < P > ( & self , base : P ) -> crate :: rewrite_output_type ! ( core :: result :: Result < & Self , std :: path :: StripPrefixError > ) where P : core :: convert :: AsRef < std :: path :: Path >;
fn symlink_metadata_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > );
fn to_str_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & str > );
fn try_exists_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > );
#[cfg(feature = "path_file_prefix")]
fn file_prefix_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > );
}
impl PathContext for std :: path :: Path {
fn canonicalize_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    std :: path :: Path :: canonicalize(self)
        .with_context(|| crate::call_failed!(Some(self), "canonicalize"))
}
fn extension_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > ) {
    std :: path :: Path :: extension(self)
        .with_context(|| crate::call_failed!(Some(self), "extension"))
}
fn file_name_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > ) {
    std :: path :: Path :: file_name(self)
        .with_context(|| crate::call_failed!(Some(self), "file_name"))
}
fn file_stem_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > ) {
    std :: path :: Path :: file_stem(self)
        .with_context(|| crate::call_failed!(Some(self), "file_stem"))
}
fn metadata_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {
    std :: path :: Path :: metadata(self)
        .with_context(|| crate::call_failed!(Some(self), "metadata"))
}
fn parent_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & Self > ) {
    std :: path :: Path :: parent(self)
        .with_context(|| crate::call_failed!(Some(self), "parent"))
}
fn read_dir_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: ReadDir > ) {
    std :: path :: Path :: read_dir(self)
        .with_context(|| crate::call_failed!(Some(self), "read_dir"))
}
fn read_link_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    std :: path :: Path :: read_link(self)
        .with_context(|| crate::call_failed!(Some(self), "read_link"))
}
fn strip_prefix_wc < P > ( & self , base : P ) -> crate :: rewrite_output_type ! ( core :: result :: Result < & Self , std :: path :: StripPrefixError > ) where P : core :: convert :: AsRef < std :: path :: Path > {
    let base = base.as_ref();
    std :: path :: Path :: strip_prefix(self, base)
        .with_context(|| crate::call_failed!(Some(self), "strip_prefix", base))
}
fn symlink_metadata_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {
    std :: path :: Path :: symlink_metadata(self)
        .with_context(|| crate::call_failed!(Some(self), "symlink_metadata"))
}
fn to_str_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & str > ) {
    std :: path :: Path :: to_str(self)
        .with_context(|| crate::call_failed!(Some(self), "to_str"))
}
fn try_exists_wc ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {
    std :: path :: Path :: try_exists(self)
        .with_context(|| crate::call_failed!(Some(self), "try_exists"))
}
#[cfg(feature = "path_file_prefix")]
fn file_prefix_wc ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: ffi :: OsStr > ) {
    std :: path :: Path :: file_prefix(self)
        .with_context(|| crate::call_failed!(Some(self), "file_prefix"))
}
}


pub fn absolute_wc < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    let path = path.as_ref();
    std :: path :: absolute(path)
        .with_context(|| crate::call_failed!(None::<()>, "std :: path :: absolute", path))
}
